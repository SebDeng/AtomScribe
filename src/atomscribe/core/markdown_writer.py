"""Markdown writer - generates documentation from analyzed transcript and frames.

Supports two document modes:
- Training: Step-by-step tutorial with operation screenshots and before/after comparisons
- Experiment Log: Findings-focused document highlighting important discoveries
"""

from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import Optional, List
from dataclasses import dataclass
from loguru import logger

from .transcript_analyzer import KeyPoint, KeyPointType


@dataclass
class ImageReference:
    """Reference to an image for inclusion in markdown."""
    path: Path  # Full path to image
    relative_path: str  # Relative path for markdown
    caption: str  # Image caption
    alt_text: str  # Alt text for accessibility


@dataclass
class DocumentSection:
    """A section of the generated document."""
    heading: str
    content: str
    images: List[ImageReference]
    key_point: Optional[KeyPoint] = None


class MarkdownWriter:
    """Generates markdown documentation from key points and images."""

    # Template for training mode document
    TRAINING_TEMPLATE = """# {title}

> Generated on {date} | Duration: {duration}

## Overview

{overview}

---

{sections}

---

## Summary

{summary}

---

*Generated by AtomScribe*
"""

    # Template for experiment log document
    EXPERIMENT_LOG_TEMPLATE = """# {title}

> Experiment Log - {date}

## Session Info

- **Duration**: {duration}
- **Total Observations**: {observation_count}
- **Key Discoveries**: {discovery_count}

---

## Key Findings

{findings}

---

## Detailed Log

{sections}

---

## Conclusions

{conclusions}

---

*Generated by AtomScribe*
"""

    def __init__(self, output_dir: Path, images_subdir: str = "images"):
        """Initialize markdown writer.

        Args:
            output_dir: Directory to write markdown and images
            images_subdir: Subdirectory name for images
        """
        self.output_dir = output_dir
        self.images_dir = output_dir / images_subdir
        self.images_subdir = images_subdir

        # Ensure directories exist
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.images_dir.mkdir(parents=True, exist_ok=True)

    def _format_duration(self, seconds: float) -> str:
        """Format duration in human-readable format."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)

        if hours > 0:
            return f"{hours}h {minutes}m {secs}s"
        elif minutes > 0:
            return f"{minutes}m {secs}s"
        else:
            return f"{secs}s"

    def _format_timestamp(self, seconds: float) -> str:
        """Format timestamp as MM:SS."""
        minutes = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{minutes:02d}:{secs:02d}"

    def _make_relative_path(self, image_path: Path) -> str:
        """Convert absolute image path to relative path for markdown."""
        try:
            return f"./{self.images_subdir}/{image_path.name}"
        except Exception:
            return str(image_path)

    def _create_image_markdown(
        self,
        image_ref: ImageReference,
        inline: bool = False,
    ) -> str:
        """Create markdown for an image.

        Args:
            image_ref: Image reference
            inline: If True, don't add newlines

        Returns:
            Markdown string for the image
        """
        md = f"![{image_ref.alt_text}]({image_ref.relative_path})"
        if image_ref.caption and not inline:
            md += f"\n\n*{image_ref.caption}*"
        return md

    def _create_before_after_table(
        self,
        before_image: ImageReference,
        after_image: ImageReference,
    ) -> str:
        """Create a before/after comparison table.

        Args:
            before_image: Before screenshot reference
            after_image: After screenshot reference

        Returns:
            Markdown table string
        """
        return f"""| Before | After |
|:------:|:-----:|
| ![Before]({before_image.relative_path}) | ![After]({after_image.relative_path}) |
| {before_image.caption} | {after_image.caption} |"""

    def generate_training_document(
        self,
        key_points: List[KeyPoint],
        title: str = "Training Document",
        duration: float = 0,
        images: Optional[dict] = None,
    ) -> str:
        """Generate a training-style document.

        Args:
            key_points: List of extracted key points
            title: Document title
            duration: Recording duration in seconds
            images: Dict mapping key point index to image references
                   Format: {idx: {"main": ImageRef, "before": ImageRef, "after": ImageRef}}

        Returns:
            Generated markdown content
        """
        images = images or {}
        sections_md = []
        step_num = 0

        # Group key points by type for overview
        actions = [kp for kp in key_points if kp.type == KeyPointType.ACTION]
        observations = [kp for kp in key_points if kp.type == KeyPointType.OBSERVATION]
        instructions = [kp for kp in key_points if kp.type == KeyPointType.INSTRUCTION]

        # Generate overview
        overview_parts = []
        if actions:
            overview_parts.append(f"- **{len(actions)} operations** demonstrated")
        if observations:
            overview_parts.append(f"- **{len(observations)} key observations** noted")
        if instructions:
            overview_parts.append(f"- **{len(instructions)} explanations** provided")
        overview = "\n".join(overview_parts) if overview_parts else "No key points extracted."

        # Generate sections for each key point
        for idx, kp in enumerate(key_points):
            section_md = []

            # Determine section heading based on type
            if kp.type == KeyPointType.ACTION:
                step_num += 1
                heading = f"### Step {step_num}: {self._extract_action_title(kp.text)}"
            elif kp.type == KeyPointType.OBSERVATION:
                heading = f"### Observation at {self._format_timestamp(kp.start_time)}"
            elif kp.type == KeyPointType.DISCOVERY:
                heading = f"### Important Finding at {self._format_timestamp(kp.start_time)}"
            else:
                heading = f"### Note at {self._format_timestamp(kp.start_time)}"

            section_md.append(heading)
            section_md.append("")
            section_md.append(kp.text)
            section_md.append("")

            # Add images if available
            if idx in images:
                img_data = images[idx]

                if kp.needs_comparison and "before" in img_data and "after" in img_data:
                    # Before/after comparison
                    section_md.append("#### Before and After")
                    section_md.append("")
                    section_md.append(self._create_before_after_table(
                        img_data["before"], img_data["after"]
                    ))
                    section_md.append("")
                elif "main" in img_data:
                    # Single screenshot
                    section_md.append(self._create_image_markdown(img_data["main"]))
                    section_md.append("")

            sections_md.append("\n".join(section_md))

        # Generate summary
        summary_items = []
        if step_num > 0:
            summary_items.append(f"- Covered **{step_num} operation steps**")
        if observations:
            summary_items.append(f"- Made **{len(observations)} observations**")
        summary = "\n".join(summary_items) if summary_items else "Document generation complete."

        # Fill template
        return self.TRAINING_TEMPLATE.format(
            title=title,
            date=datetime.now().strftime("%Y-%m-%d %H:%M"),
            duration=self._format_duration(duration),
            overview=overview,
            sections="\n\n".join(sections_md),
            summary=summary,
        )

    def generate_experiment_log(
        self,
        key_points: List[KeyPoint],
        title: str = "Experiment Log",
        duration: float = 0,
        images: Optional[dict] = None,
    ) -> str:
        """Generate an experiment log document.

        Args:
            key_points: List of extracted key points
            title: Document title
            duration: Recording duration in seconds
            images: Dict mapping key point index to image references

        Returns:
            Generated markdown content
        """
        images = images or {}
        sections_md = []

        # Categorize key points
        discoveries = [kp for kp in key_points if kp.type == KeyPointType.DISCOVERY]
        observations = [kp for kp in key_points if kp.type == KeyPointType.OBSERVATION]
        actions = [kp for kp in key_points if kp.type == KeyPointType.ACTION]

        # Generate key findings section
        findings_md = []
        for kp in discoveries:
            findings_md.append(f"- **{self._format_timestamp(kp.start_time)}**: {kp.text}")
        if not findings_md:
            for kp in observations[:3]:  # Use top 3 observations as findings
                findings_md.append(f"- **{self._format_timestamp(kp.start_time)}**: {kp.text}")
        findings = "\n".join(findings_md) if findings_md else "No significant findings recorded."

        # Generate detailed log sections
        for idx, kp in enumerate(key_points):
            section_md = []

            # Timestamp heading
            heading = f"### [{self._format_timestamp(kp.start_time)}] {kp.type.value.capitalize()}"
            section_md.append(heading)
            section_md.append("")

            # Content with appropriate styling
            if kp.type == KeyPointType.DISCOVERY:
                section_md.append(f"> **{kp.text}**")
            else:
                section_md.append(kp.text)
            section_md.append("")

            # Add images if available
            if idx in images:
                img_data = images[idx]
                if "main" in img_data:
                    section_md.append(self._create_image_markdown(img_data["main"]))
                    section_md.append("")

            sections_md.append("\n".join(section_md))

        # Generate conclusions
        conclusions_items = []
        if discoveries:
            conclusions_items.append(f"- Made {len(discoveries)} key discoveries during this session")
        if observations:
            conclusions_items.append(f"- Recorded {len(observations)} observations")
        if actions:
            conclusions_items.append(f"- Performed {len(actions)} operations")
        conclusions = "\n".join(conclusions_items) if conclusions_items else "Session completed."

        # Fill template
        return self.EXPERIMENT_LOG_TEMPLATE.format(
            title=title,
            date=datetime.now().strftime("%Y-%m-%d %H:%M"),
            duration=self._format_duration(duration),
            observation_count=len(observations),
            discovery_count=len(discoveries),
            findings=findings,
            sections="\n\n".join(sections_md),
            conclusions=conclusions,
        )

    def _extract_action_title(self, text: str, max_length: int = 50) -> str:
        """Extract a short title from action text.

        Args:
            text: Full action text
            max_length: Maximum title length

        Returns:
            Short title string
        """
        # Take first sentence or first N characters
        sentences = text.split('.')
        title = sentences[0].strip()

        if len(title) > max_length:
            title = title[:max_length - 3] + "..."

        return title if title else "Perform operation"

    def write_document(
        self,
        content: str,
        filename: str = "summary.md",
    ) -> Path:
        """Write markdown content to file.

        Args:
            content: Markdown content
            filename: Output filename

        Returns:
            Path to written file
        """
        output_path = self.output_dir / filename

        try:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(content)
            logger.info(f"Written markdown document to {output_path}")
            return output_path
        except Exception as e:
            logger.error(f"Failed to write markdown: {e}")
            raise

    def create_image_reference(
        self,
        source_path: Path,
        caption: str = "",
        alt_text: str = "",
        copy_to_images_dir: bool = True,
    ) -> ImageReference:
        """Create an image reference, optionally copying the image.

        Args:
            source_path: Path to source image
            caption: Image caption
            alt_text: Alt text for accessibility
            copy_to_images_dir: If True, copy image to images directory

        Returns:
            ImageReference object
        """
        if copy_to_images_dir:
            dest_path = self.images_dir / source_path.name
            if source_path != dest_path:
                import shutil
                shutil.copy2(source_path, dest_path)
            final_path = dest_path
        else:
            final_path = source_path

        return ImageReference(
            path=final_path,
            relative_path=self._make_relative_path(final_path),
            caption=caption or "",
            alt_text=alt_text or source_path.stem,
        )


def create_markdown_writer(output_dir: Path) -> MarkdownWriter:
    """Factory function to create a markdown writer.

    Args:
        output_dir: Directory for output files

    Returns:
        MarkdownWriter instance
    """
    return MarkdownWriter(output_dir)
